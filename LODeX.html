<!doctype html>

<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Fogli di stile -->
    <!-- <link rel="stylesheet"  type="text/css" href="css/bootstrap.css"> -->
    <link rel="stylesheet" type="text/css" href="css/bootstrap.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/search-box.css">

    <!-- questi tre modificano la pagina -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">



</head>

<style>
    body {
        margin-top: 66px;
        /*per evitare che il contenuto della pagina finisca sotto la navbar*/
        padding: 0px;
    }

    /* STILE BARRA ALTO */

    .navbar-brand {
        display: inline-block;
        padding-top: .3125rem;
        padding-bottom: .3125rem;
        margin-right: 8rem;
        margin-left: 5rem;
        font-size: 2rem;
        height: 50px;
        line-height: 35px;
        white-space: nowrap;
    }
</style>

<body>

    <!-- Barra Iniziale -->
    <nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <ul class="nav navbar-nav" id="myTab" role="tablist">
                <li class="nav-item">
                    <a class="navbar-brand nav-link active" id="dataset-tab" data-toggle="tab" href="#dataset" role="tab" aria-controls="home"
                        aria-selected="true">LODeX
                        <span class="sr-only">(current)</span>
                    </a>
                </li>
                <li class="nav-item">
                    <a class="navbar-brand nav-link" id="graph-tab" data-toggle="tab" href="#graph" role="tab" aria-controls="profile" aria-selected="false">Graph View</a>
                </li>
                <li class="nav-item">
                    <a class="navbar-brand nav-link" id="query-tab" data-toggle="tab" href="#query" role="tab" aria-controls="contact" aria-selected="false">Query Panel</a>
                </li>
            </ul>
        </div>
    </nav>

    <div class="tab-content" id="myTabContent">
        <div class="tab-pane fade show active" id="dataset" role="tabpanel" aria-labelledby="dataset-tab">

            <table class="table table-hover" id="myTable">
                <thead>
                    <tr class="tr-fixed">
                        <th>
                            <a>Dataset Name</a>


                            <!--
<div class="search-container">

<form action="#dataset" method="get">
<input type="text" placeholder="Search.." id="search">
<button type="submit"><i class="fa fa-search"></i></button>
</form>

</div>

-->

                            <div class="search-box-wrapper">
                                <input type="text" placeholder="Search..." class="search-box-input">
                                <button class="search-box-button">&#128269;</button>
                            </div>

                            <a href="#" onclick="sortTable(0)">
                                <i class="fa fa-sort-alpha-asc" style="font-size:24px"></i>
                                  </a>
                            <a href="#" onclick="sortTable(0)">
                                <i class="fa fa-sort-alpha-desc" style="font-size:24px"></i>
                            </a>
                        </th>



                        <th> <a>Triples</a>
                            <a href="#" onclick="sortNumber(1)">
                                <i class="fa fa-sort-numeric-asc" style="font-size:24px"></i>
                                  </a>
                            <a href="#" onclick="sortNumber(1)">
                                <i class="fa fa-sort-numeric-desc" style="font-size:24px"></i>
                                </a>
                        </th>

                        <th> <a>Class Number</a>
                            <a href="#">
                                <i class="fa fa-sort-numeric-asc" style="font-size:24px"></i>
                                  </a>
                            <a href="#">
                                <i class="fa fa-sort-numeric-desc" style="font-size:24px"></i>
                                </a>
                        </th>

                        <th> <a>Properties Number</a>
                            <a href="#">
                                <i class="fa fa-sort-numeric-asc" style="font-size:24px"></i>
                                  </a>
                            <a href="#">
                                <i class="fa fa-sort-numeric-desc" style="font-size:24px"></i>
                                </a>
                        </th>

                        <th> <a>Instance Number</a>
                            <a href="#">
                                <i class="fa fa-sort-numeric-asc" style="font-size:24px"></i>
                                  </a>
                            <a href="#">
                                    <span class="glyphicon glyphicon-sort-by-order-alt"></span>
                                </a>
                        </th>

                        <th>Azioni</th>

                    </tr>
                </thead>
                <tbody id="dataset-elements">

                </tbody>
            </table>

        </div>
        <div class="tab-pane fade" id="graph" role="tabpanel" aria-labelledby="graph-tab">d</div>
        <div class="tab-pane fade" id="query" role="tabpanel" aria-labelledby="query-tab">...</div>
    </div>

    <script id="template-dataset-elements" type="text/template7">
            {{#each data}}
            <tr>
                <td> {{name}} </td>
                <td> {{triples}} </td>
                <td> {{classesCount}} </td>
                <td> {{propCount}} </td>
                <td> {{instances}} </td>
                <td>
                <td>
                    <div class="btn-group" role="group" aria-label="Basic example">
                        <button type="button" class="ssbtn btn btn-success" data-id="{{ id }}">SS</button>
                        <button type="button" class="csbtn btn btn-danger" data-id="{{ id }}">CS</button>
                    </div>
                </td>
                </td>
            </tr>
            {{/each}}
        </script>

    <!-- jQuery e plugin JavaScript  -->
    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/template7.min.js"></script>
    <script src="js/d3.js"></script>

    <script>
var colorGlobal = d3.scale.category20();
        var fill = d3.scale.category20();


        $.ajax({
            type: 'GET',
            url: './index',
            dataType: 'json',
            success: function (data) {

                var template = $('#template-dataset-elements').html();
                var compiledTemplate = Template7.compile(template);
                $('#dataset-elements').html(compiledTemplate(data));




                $('#dataset-elements .ssbtn').click(function () {

                    var ssid = $(this).data("id");
                    $('#myTab a[href="#graph"]').tab('show');
                    $.ajax({
                        type: 'GET',
                        url: './getDataSS/' + ssid,
                        dataType: 'json',
                        success: function (data) {
                            console.log(data);
                        }
                    });

                });




                $('#dataset-elements .csbtn').click(function () {

                    var csid = $(this).data("id");
                    $('#myTab a[href="#graph"]').tab('show');
                    $.ajax({
                        type: 'GET',
                        url: './getDataCS/' + csid,
                        dataType: 'json',
                        success: function (data) {
                            console.log(data);
                        }
                    });

                });




            }
        });
    </script>


    <script>
        function sortTable(n) {
            var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
            table = document.getElementById("myTable");
            switching = true;
            //Set the sorting direction to ascending:
            dir = "asc";
            /*Make a loop that will continue until
            no switching has been done:*/
            while (switching) {
                //start by saying: no switching is done:
                switching = false;
                rows = table.getElementsByTagName("TR");
                /*Loop through all table rows (except the
                first, which contains table headers):*/
                for (i = 1; i < (rows.length - 1); i++) {
                    //start by saying there should be no switching:
                    shouldSwitch = false;
                    /*Get the two elements you want to compare,
                    one from current row and one from the next:*/
                    x = rows[i].getElementsByTagName("TD")[n];
                    y = rows[i + 1].getElementsByTagName("TD")[n];
                    /*check if the two rows should switch place,
                    based on the direction, asc or desc:*/
                    if (dir == "asc") {
                        if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                            //if so, mark as a switch and break the loop:
                            shouldSwitch = true;
                            break;
                        }
                    } else if (dir == "desc") {
                        if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
                            //if so, mark as a switch and break the loop:
                            shouldSwitch = true;
                            break;
                        }
                    }
                }
                if (shouldSwitch) {
                    /*If a switch has been marked, make the switch
                    and mark that a switch has been done:*/
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    //Each time a switch is done, increase this count by 1:
                    switchcount++;
                } else {
                    /*If no switching has been done AND the direction is "asc",
                    set the direction to "desc" and run the while loop again.*/
                    if (switchcount == 0 && dir == "asc") {
                        dir = "desc";
                        switching = true;
                    }
                }
            }
        }
    </script>



<script>
    function sortNumber(n) {
      var table, rows, switching, i, x, y, shouldSwitch;
      table = document.getElementById("myTable");
      switching = true;
      /*Make a loop that will continue until
      no switching has been done:*/
      while (switching) {
        //start by saying: no switching is done:
        switching = false;
        rows = table.getElementsByTagName("TR");
        /*Loop through all table rows (except the
        first, which contains table headers):*/
        for (i = 1; i < (rows.length - 1); i++) {
          //start by saying there should be no switching:
          shouldSwitch = false;
          /*Get the two elements you want to compare,
          one from current row and one from the next:*/
          x = rows[i].getElementsByTagName("TD")[n];
          y = rows[i + 1].getElementsByTagName("TD")[n];
          //check if the two rows should switch place:
          if (Number(x.innerHTML) > Number(y.innerHTML)) {
            //if so, mark as a switch and break the loop:
            shouldSwitch = true;
            break;
          }
        }
        if (shouldSwitch) {
          /*If a switch has been marked, make the switch
          and mark that a switch has been done:*/
          rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
          switching = true;
        }
      }
    }
    </script>



<!-- https://www.w3schools.com/howto/howto_js_sort_table.asp -->
    <!--http://www.terrill.ca/sorting/-->


    <script>

            var colorGlobal=d3.scale.category20();
            var svg;
            var qo;
            var ssGlobal;
            var fill = d3.scale.category20();
            var stroke_width = 1.5;
            var tick = false;
            var linkDistance=150;
        
            function isEmpty(obj) {
        
                // null and undefined are "empty"
                if (obj == null) return true;
        
                // Assume if it has a length property with a non-zero value
                // that that property is correct.
                if (obj.length > 0)    return false;
                if (obj.length === 0)  return true;
        
                // Otherwise, does it have any properties of its own?
                // Note that this doesn't handle
                // toString and valueOf enumeration bugs in IE < 9
                for (var key in obj) {
                    if (hasOwnProperty.call(obj, key)) return false;
                }
        
                return true;
            }
            var ssGraph = {
                    width:0,
                    height:0,
                    eightyWeight:0,
                    svg:null,
        
                    selectedChanged:function(par){
        //         		console.log('changed')
                        //console.log(this.selected)
        
        
                        this.fire('overnode',par)
                        svg.selectAll('.link').style('opacity', function(o) {
                               if (o.source == this.selected || o.target == this.selected)return o.source == this.selected || o.target == this.selected ? 1 : 0.3;
                           }.bind(this)).style("stroke-width", function(o) {
                               if (o.source == this.selected || o.target == this.selected)
                             return o.source == this.selected || o.target == this.selected ? 3 : 1;
                         }.bind(this));
        
        //           	   console.log(this.ss)
        
                         svg.selectAll('.node')
                           .style('opacity', function(ld) {
        
                               if (ld.fullName == this.selected.fullName) return 1;
                               if (_.some(this.ss.links,function(el){
                                   return (el.source===this.selected && el.target===ld)||(el.source===ld && el.target===this.selected);
                               }.bind(this))) {
                               return 1;
                               }
                               else if (typeof ld !== 'undefined') return .4;
                           }.bind(this));
        //           	 console.log(this.selected)
        
        
                           svg.selectAll('.nodelabel')
                           .style('opacity', function(ld) {
        //          			console.log(d)
        //      			console.log(ld)
        // 					console.log(this.selected)
                           if (typeof ld !== 'undefined' && ld.fullName == this.selected.fullName) return 1;
        //       	       if (typeof ld !== 'undefined')console.log(ld.fullName);
        //      				console.log(d)
                           if (_.some(this.ss.links,function(el){
        //      	         	 console.log(el.target);
                               return (el.source===this.selected && el.target===ld)||(el.source===ld && el.target===this.selected);
                           }.bind(this))) {
                           return 1;
                           }
                           else if (typeof ld !== 'undefined') return .4;
                       }.bind(this))
                       .style('font-weight', function(ld) {
                           if (typeof ld !== 'undefined' && ld.name == this.selected.name) return 500;
                          //		console.log(ld)
                          //		console.log(d)
                          if (_.some(this.ss.links,function(el){
                          //	 console.log(el.target);
                               return (el.source===this.selected && el.target===ld)||(el.source===ld && el.target===this.selected);
                          }.bind(this))) {
                          return 500;
                          }
                          else return 300;}.bind(this));
        
                    },
                    ssChanged: function(attrName, oldVal, newVal) {
                        if (!isEmpty(this.ss)){
                            // inizializzazione
                                                                
        
                            qo=new QuerOrchestrator();
                            this.queryStarted=false;
        
                            var margin = {top: -5, right: -5, bottom: -5, left: -5};
        
                            this.width=this.getBoundingClientRect().width*0.99;
                            this.height=this.getBoundingClientRect().height*0.99;
                            this.eightyWeight=this.width*0.8
                            console.log(this.width)
                            var div = this.$.graph
                            while (div.hasChildNodes() && div.lastChild.id != "title") {
                                div.removeChild(div.lastChild);
                            }
                            ssGlobal=this.ss
                            console.log("MERDA",ssGlobal)
                            //console.log(svg)
        
                            svg = d3.select(this.$.graph).append("svg")
                            .attr("width", this.width )
                            .attr("height", this.height )
                            .append("g")
        //             		.attr("transform", "translate(" + margin.left + "," + margin.right + ")")
        
        
        
        // 	        		svg = d3.select()
        // 	    			.append("svg:svg")
        // 	    			    .attr("width", this.width)
        // 	    			    .attr("height", this.height)
        // 	    			    .attr("pointer-events", "all")
        // 	    		    .append('svg:g')
        // 	    		    .attr("id","ggraph")
        // 	    		    .attr("x",0)
        // 	    		    .attr("y",0)
        // 	    		    .attr("width", this.width)
        // 	    			    .attr("height", this.height)
                                //.call(d3.behavior.zoom().on("zoom", redraw)) //bug quando viene chiamat la funzione tick, si scatena anche redraw
        
        
        // 	    			svg.append('svg:rect')
        // 	    		    .attr('width', this.width)
        // 	    		    .attr('height', this.height)
        // 	    		    .attr('fill', 'none');
        
                            this.drawGraph();
                        }
                    },
                drawGraph:function(graph){
                    //console.log(this.ss);
        
                    var vocab=this.ss.vocab;
        
                    colorGlobal=d3.scale.category20();
        
        
                    var rect = svg.append("rect")
                    .attr("width", this.width)
                    .attr("height", this.height)
                    .style("fill", "none")
                    .style("pointer-events", "all");
        
                    var container = svg.append("g");
        
        
                    for (a in vocab){
                        colorGlobal(vocab[a]);
                    }
                    // console.log(vocab[0]);
                    var max_ni = this.ss.nodes[0].ni;
                    var max_np = this.ss.links[0].np;
        
                    /*var legend = svg.selectAll(".legend")
                    .data(this.ss.vocab)
                    .enter().append("g")
                    .attr("class", "legend")
                    .attr("y", "5px")
                    .attr("transform", function(d, i) { return "translate(0," + ((i * 17)+5) + " )"; });
        
            // draw legend colored rectangles
                    legend.append("rect")
                        .attr("x", this.width-15 )
                        .attr("width", 15)
                        .attr("height", 15)
                          .style("fill", colorGlobal);
        
            // draw legend text
                    legend.append("text")
                          .attr("x", this.width - 21)
                        .attr("y", 9)
                        .attr("dy", ".35em")
                        .style("text-anchor", "end")
                        .style("font-family","Lato, sans-serif")
                        .style("font-size", "14px")
                        .style("font-weight", 900)
                        .text(function(d) { return d;});  */
        
        
        
                    for(i = 1; i < this.ss.nodes.length; i++){
                        if(this.ss.nodes[i].ni > max_ni)
                            max_ni = this.ss.nodes[i].ni;
                    }
                    //console.log(min_ni);
                    //console.log(max_ni);
                    for(i = 1; i < this.ss.links.length; i++){
                        if(this.ss.links[i].np > max_np)
                            max_np = this.ss.links[i].np;
                    }
                    // console.log(max_np);
                    // console.log((2500) * 31 / graph.nodes.length);
                    // console.log(graph.nodes.length);
                    //debugger;
                    var charge = (-4100) * 31 / this.ss.nodes.length;
        
                    // var svg = d3.select("body").append("svg").attr({"width":width,"height":height});
        
                    console.log(charge)
        
                   var force = d3.layout.force()
                        .nodes(this.ss.nodes)
                         .links(this.ss.links)
                        .gravity(0.9).linkDistance([linkDistance])
                        .charge(charge)
                          .friction(0.7)
                        .size([this.width, this.height])
                        .start();
        
        
        
        
        
        // symmetricDiffLinkLengths(100)
        
                    console.log(parseInt(-(2/3)*this.ss.nodes.length+100))
        
        
        //     	    var force = cola.d3adaptor().linkDistance(parseInt(-(2/3)*this.ss.nodes.length+100))
        // 			.nodes(this.ss.nodes)
        // 			.links(this.ss.links)
        // 			.size([this.width, this.height])
        // 			.start();
        
        
        
                    var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 10])
                    .on("zoom", zoomed);
        
                    svg.call(zoom);
        
                var drag = d3.behavior.drag()
                    .origin(function(d) { return d; })
                    .on("dragstart", dragstarted)
                    .on("drag", dragged)
                    .on("dragend", dragended);
        
                    divTT = d3.select("#chart").append("div")
                        .attr("class", "tooltip")
                        .style("position", "absolute")
                        .style("top", 5)
                        .style("left",5)
                        // 	 .style("z-index",-1)
                        .style("opacity", 1);
        
        //
                    var edgeLegend	= d3.select("#chart").append("div")
                        .attr("class", "edgeLegend")
                        .attr({
                            'width': '20px',
                            'height': '10px',
                            'position': 'absolute',
                            'overflow-y': 'auto'
                        })
                        .style("position", "absolute")
                    // 	 .style("z-index",-1)
                        .style("opacity", 1);
        
        
                    var links = container
                    .attr("class", "links")
                    .selectAll(".link")
                          .data(this.ss.links)
                          .enter().append("svg:line") //
                          .attr("class", "link")
                          .attr("id",function(d,i) {return 'edge'+i;})
                          .attr('marker-end','url(#arrowhead)')
                          .style("stroke-width", 1 )
                          .attr("x1", function(d) { return d.source.x; })
                          .attr("y1", function(d) { return d.source.y; })
                            .attr("x2", function(d) { return d.target.x; })
                            .attr("y2", function(d) { return d.target.y; })//;
        
                    autoedges=[]
                    for(i=0;i<this.ss.links.length;i++){
                        if(this.ss.links[i].source == this.ss.links[i].target){
        //    	    		console.log('autonode')
                            autoedges.push(this.ss.links[i])
                        }
                    }
        
                    var autoedges = container
                    .selectAll(".autoedges")
                        .data(autoedges)
                        .enter().append("svg:path") //
                          .attr("class", "link")
                          .attr("id",function(d,i) {return 'autoedge'+i;})
                      //.style("stroke-width", function(d) { return (d.np * 10 / max_np) + 1;; })
                          .style("stroke-width", "1.5px")
                          .attr("fill", "none")
                      // .attr('marker-end','url(#arrowhead)')
                          .style("stroke",'black');
                      //.style("pointer-events", "none");
        
                    var nodes = container
                    .attr("class", "nodes")
                    .selectAll(".node")
                      .data(this.ss.nodes)
                      .enter().append("svg:circle")
                      .attr("class", "node")
                      .attr("stroke", "black")
                      .attr("stroke-width", "0.5px")
                      .attr("r", function(d) { return (d.ni * 20 / max_ni)+5; }) //dimensione nodi
                         .style("fill", function(d) { return colorGlobal(d.vocab); })
        //     	      .on("dblclick", dblclick)
        //     	      .on("click",nodeClick)
                      .call(drag)
        
        
        
                    var nodelabels = container
                    .attr("class", "nodelabel")
                    .selectAll(".nodelabel")
                       .data(this.ss.nodes)
                       .enter()
                       .append("text")
                       .attr({"x":function(d){return d.x+ (d.ni * 25 / max_ni) + 5  + stroke_width; },
                              "y":function(d){return d.y;},
                              "class":"nodelabel",
                              "id":function(d){return "nodelabel"+d.index}})
                        .style("font-family","Lato, sans-serif")
                        .style("font-weight", 300)
                        .style("stroke","black")
                        .attr("font-size", "13px")
                        .attr("fill", "black")
        //     			.append("tspan")
        //     			.attr('id',function(d){return "nodelabeltspan"+d.index})
                       .text(function(d){return d.name;})
        //     	       .insertBefore(svg.select(function(d){return "#nodelabeltspan"+d.index}),document.createElement("tspan"))
        //     	       .text(function(d){return d.name;});
        
        
        
        
                    nodes.append("title")
                        .text(function(d) { return d.fullName; });
                    links.append("title")
                        .text(function(d) { return d.name; });
        
                    svg.style("opacity", 1e-6)
                        .transition()
                        .duration(1000)
                        .style("opacity", 1);
        
        
        
                    var edgepaths = svg.selectAll(".edgepath")
                        .data(this.ss.links)
                        .enter()
                        .append('path')
                        .attr({'d': function(d) {return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},
                               'class':'edgepath',
                               'fill-opacity':0,
                               'stroke-opacity':0,
                               'fill':'blue',
                               'stroke':'red',
                               'id':function(d,i) {return 'edgepath'+i}})
                        .style("pointer-events", "none");
        
        
        
        
                    force.on("tick", function(){
        
        
                        nodes.attr({"cx":function(d){return d.x = Math.max(10, Math.min(this.width - 10, d.x));}.bind(this),
                                    "cy":function(d){return d.y = Math.max(10, Math.min(this.height - 10, d.y)) ;}.bind(this)
                        });
        
                        links.attr({"x1": function(d){return d.source.x;},
                            "y1": function(d){return d.source.y;},
                            "x2": function(d){return d.target.x;},
                            "y2": function(d){return d.target.y;}
                    });
        
                        nodelabels.attr("x", function(d){return d.x+ (d.ni * 25 / max_ni) + 5  + stroke_width;})
                                  .attr("y", function(d) { return d.y; });
        
        
        //     	        edgepaths.attr("x1", function(d) { return d.source.x; })
        //     	        .attr("y1", function(d) { return d.source.y; })
        //     	        .attr("x2", function(d) { return d.target.x; })
        //     	        .attr("y2", function(d) { return d.target.y; });
        
                        edgepaths.attr('d', function(d) { var path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;
                                                           //console.log(d)
                                                           return path});
        
        
                         autoedges.attr("d", function(d) {
                             var dx = d.target.x - d.source.x,
                                dy = d.target.y - d.source.y,
                                dr = Math.sqrt(dx * dx + dy * dy),
                                x1 = d.source.x,
                                y1 = d.source.y,
                                x2 = d.target.x,
                                y2 = d.target.y;
        
                            var xRotation = 0, // degrees
                                largeArc = 0, // 1 or 0
                                sweep = 1; // 1 or 0
                                xRotation = -45;
        
                                    // Needs to be 1.
                                largeArc = 1;
        
                                // Change sweep to change orientation of loop.
                                //sweep = 0;
        
                                // Make drx and dry different to get an ellipse
                                // instead of a circle.
                                drx = 30;
                                dry = 20;
        
                                // For whatever reason the arc collapses to a point if the beginning
                                // and ending points of the arc are the same, so kludge it.
                                x2 = x2 + 1;
                                y2 = y2 + 1;
                                return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;
        
                        });
        
                    }.bind(this));
        
                    function zoomed() {
                          container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                        }
        
                        function dragstarted(d) {
                          d3.event.sourceEvent.stopPropagation();
        
                          d3.select(this).classed("dragging", true);
        //     	          console.log(force)
                          force.start();
                        }
        
                        function dragged(d) {
        
                          d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
        
                        }
        
                        function dragended(d) {
        
                          d3.select(this).classed("dragging", false);
                        }
        
                    svg.selectAll('.node').on("mouseover", function(d){this.selected=d}.bind(this));
        
                   
                },
                nodeMouseOver:function(d,par){
        // 			console.log(par)
                    this.selected=d;
        
        
        
                }
        
        
        
                }
        
        
        
        
        
        
                </script>


<script>
        var vis;
        var graphsmal = {
                width:0,
                height:0,
                eightyWeight:0,
                nodes2:null,
                links2:null,
                force2:null,
                over:null,
                generate:function(){
                    this.fire('generate');
                },
                clearQuery:function(){
                    this.fire('clearquery');
                    this.node2=null;
                    this.link2=null;
                    this.ssChanged();
                },
                overChanged:function(){
                    this.fire('smouseover',this.over)
                },
                ssChanged: function(attrName, oldVal, newVal) {
                    if (!isEmpty(this.ss)){
    
    
                        // set up the D3 visualisation in the specified element
                        var w = this.getBoundingClientRect().width*0.99,
                            h = this.getBoundingClientRect().height*0.79;
                        console.log(w)
    
                        var div = this.$.graph2
                        while (div.hasChildNodes()) {
                            div.removeChild(div.lastChild);
                        }
    
                        vis = d3.select(this.$.graph2).append("svg:svg")
                            .attr("width", w)
                            .attr("height", h);
    
                        this.force2 = d3.layout.force()
                            .gravity(.05)
                            .distance(100)
                            .charge(-100)
                            .size([w, h]);
    
                        this.nodes2 = this.force2.nodes(),
                        this.links2 = this.force2.links();
    
                        this.update()
                        }
    
                },
                update:function () {
    
                    var node2 = vis.selectAll("g.node")
                        .data(this.nodes2, function(d) { return d.id;});
    
                    var nodeEnter = node2.enter().append("g")
                        .attr("class", "node")
                        .call(this.force2.drag);
    
    
                    nodeEnter.append("svg:circle")
                      .attr("class", "circle")
                      .attr("stroke","black" )
                      .attr("stroke-width", "1.5px")
                      .attr("r", 10)
                      .style("fill",function(d) {return d.color})
                      .on("mouseover",function(n){this.over=n;}.bind(this))
    
    //                    .attr("xlink:href", "https://d3nwyuy0nl342s.cloudfront.net/images/icons/public.png")
    //                    .attr("x", "-8px")
    //                    .attr("y", "-8px")
    //                    .attr("width", "16px")
    //                    .attr("height", "16px");
    
                    nodeEnter.append("text")
                        .attr("class", "nodetext")
                        .attr("dx", 12)
                        .attr("dy", ".35em")
                        .style("font-family","Lato, sans-serif")
                        .style("font-weight", 500)
                        .attr("font-size", "15px")
                        .attr("fill", "black")
                        .text(function(d) {return d.id});
    
                    node2.exit().remove();
    
                    var link2 = vis.selectAll("line.link")
                    .data(this.links2, function(d) { return d.source.id + "-" + d.target.id; });
    
                link2.enter().insert("line")
                    .attr("class", "link");
    
                link2.exit().remove();
    
                    this.force2.on("tick", function() {
                      link2.attr("x1", function(d) { return d.source.x; })
                          .attr("y1", function(d) { return d.source.y; })
                          .attr("x2", function(d) { return d.target.x; })
                          .attr("y2", function(d) { return d.target.y; });
    
                      node2.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
                    });
    
                    // Restart the force layout.
                    this.force2.start();
                },
             // Add and remove elements on the graph object
                addNode2 : function (id,color,nodeID) {
                    this.nodes2.push({"id":id,"color":color,"nodeID":nodeID});
                    this.update();
                },
    
                removeNode2:function (id) {
                    var i = 0;
                    var n = this.findNode2(id);
                    while (i < this.links2.length) {
                        if ((this.links2[i]['source'] === n)||(this.links2[i]['target'] == n)) this.links2.splice(i,1);
                        else i++;
                    }
                    var index2 = this.findNode2Index(id);
                    if(index2 !== undefined) {
                        this.nodes2.splice(index2, 1);
                        this.update();
                    }
                },
    
                addLink2 : function (sourceId, targetId) {
                    var sourceNode2 = this.findNode2(sourceId);
                    var targetNode2 = this.findNode2(targetId);
    
                    if((sourceNode2 !== undefined) && (targetNode2 !== undefined)) {
                        this.links2.push({"source": sourceNode2, "target": targetNode2});
                        this.update();
                    }
                },
    
                findNode2 : function (id) {
                    for (var i=0; i < this.nodes2.length; i++) {
                        if (this.nodes2[i].id === id)
                            return this.nodes2[i]
                    };
                },
    
                findNode2Index : function (id) {
                    for (var i=0; i < this.nodes2.length; i++) {
                        if (this.nodes2[i].id === id)
                            return i
                    };
                }
    
    
    
    
    
            }
            </script>




<script>

        var colorGlobal = d3.scale.category20();
        var fill = d3.scale.category20();
        Polymer({
            selected: 0,
            ss: {},
            currentId: 0,
            currentNode: null,
            communityExpanded: false,
            isCluster: false,
            classSelected: false,
            propertylist: {},
            classesList: [],
            height: 0,
            width: 0,
            queryStarted: false,
            curQCN: [],
            reachable: null,
            test: false,
            edgeClusters: null,
            nodeClusters: null,
            /*  classesLinks: [],*/
            originalTitle: "",

            removeNodeFquery: function (e) {
// 			console.log(e.detail)
                this.$.graphss.removeNode2(e.detail)
            },
            nameFontSize: function (value) {
                if (value.length > 25) {
                    return "font-size:28px"
                } else {
                    return "font.size:34px"
                }
            },
            // my custom filter function to use in looping objects
            getKeys: function (o) {
                return Object.keys(o);
            },
            generate: function () {
                this.selected = 2;
                document.location.href = "#!/refinementPanel";
                this.$.queryint.updateQuery();

            },

            checkClass: function (id) {
                var index = this.classesList.indexOf(id);
                return index !== -1;
            },

            clearQuery: function () {
                qo = new QuerOrchestrator();
                this.curQCN = [];
                this.currentNode = null;
                this.queryStarted = false;
                this.propertylist = {};
                this.$.queryint.queryChanged()
                _.each(this.ss.attributes, function (a) {
                    a.setted = false
                })
            },
            addCurrentClass: function () {
                this.queryStarted = true;


                console.log(this.currentNode);
                var curClasNode = new ClassNode(this.currentNode.fullName, this.currentNode.name, true);
                console.log(curClasNode);
                qo.addNode(curClasNode);
                this.curQCN.push({
                    index: qo.getIndex(),
                    nodeId: this.currentNode.index,
                    name: this.currentNode.name,
                    attributes: new Array(),
                    opt: false,
                    param: qo.getCurClasses()[0].getParameter(),
                    property: null,
                    qoQI: -1
                });
                console.log(this.curQCN);
                console.log(qo);
                this.currentNodeChanged();
                //TODO
                this.$.graphss2.addNode2(this.currentNode.name, colorGlobal(this.currentNode.vocab), this.currentNode.index);
                this.currentNode.param = qo.getCurClasses()[0].getParameter().substr(1);
                console.log(this.currentNode);
                this.currentNodeChanged();


            },
            addAttr: function (event, detail, targhet) {
                var curQnode = _.find(this.curQCN, function (a) {
                    return a.nodeId == this.currentNode.index && a.param.substr(1) == this.currentNode.param
                }.bind(this))
                var index = curQnode.index
                console.log(targhet.attributes)
                var name = targhet.attributes['name'].value
                var property = targhet.attributes['fullname'].value
                var optional = (targhet.attributes['mandatory'].value == 1) ? true : false
                console.log(index, name, property, optional)
                var paramId = qo.addAttributeToNode(index, name, property, optional);
                this.curQCN[index].attributes.push({opt: optional, name: name, param: paramId, fullName: property});
                this.currentNodeChanged();
                this.$.queryint.queryChanged();
            },
            addProperty: function (event, detail, targhet) {
                console.log(targhet.attributes)
                var pos = targhet.attributes['pos'].value
                var mandotary = targhet.attributes['mandatory'].value
                var entranti = targhet.attributes['entranti'].value
                var nodeID = targhet.attributes['nodeid'].value
// 			var pos=event.path[0].attributes[3].value
// 			var mandotary=event.path[0].attributes[4].value
// 			var entranti = event.path[0].attributes[5].value
// 			var nodeID= event.path[0].attributes[6].value
                var par = null;
                var nodInd = null;
                var name = null;
                var property = null;
                var curQnode = _.find(this.curQCN, function (a) {
                    return a.nodeId == this.currentNode.index
                }.bind(this))
// 			if (curQnode === undefined){
// 				curQnode=_.find(this.curQCN,function(a){return a.nodeId==nodeID}.bind(this))
// 			}
                if (entranti == 1) {

                    currentProp = _.find(this.propertylist.entranti, function (a) {
                        return a.pos == pos
                    }.bind(this))
                    var par = qo.addLinkedNode(currentProp.ClassfullName, currentProp.source, true, currentProp.fullName, true, (mandotary == 1) ? false : true, curQnode.index);
                    nodInd = currentProp.index
                    name = currentProp.source
                    property = currentProp.fullName
                } else {
                    currentProp = _.find(this.propertylist.uscenti, function (a) {
                        return a.pos == pos
                    }.bind(this))
                    var par = qo.addLinkedNode(currentProp.ClassfullName, currentProp.target, true, currentProp.fullName, false, (mandotary == 1) ? false : true, curQnode.index);
                    nodInd = currentProp.index
                    name = currentProp.target
                    property = currentProp.fullName
                }
                this.curQCN.push({
                    param: par,
                    index: qo.getIndex(),
                    nodeId: nodInd,
                    name: name,
                    attributes: new Array(),
                    opt: (mandotary == 1) ? false : true,
                    property: property,
                    othInx: this.currentNode.index,
                    qoQI: curQnode.index,
                    othParam: qo.getCurClasses()[curQnode.index].getParameter()
                });

// 			var par=qo.addLinkedNode(URI,name,parEnabl,property,Boolean.parse(after),Boolean.parse(optional),index);
// 			curQCN.push({param:par,index:qo.getIndex(),nodeId:nodInd,name:name,attributes:new Array(),opt:Boolean.parse(optional),property:property,othInx:otherInx,qoQI:parseInt(index),othParam:qo.getCurClasses()[index].getParameter()});

// 			var idClass = _.find(curQCN,function(a){return a.param==par}).nodeId;
                newNodes = this.isCluster ? this.ss.classes : this.ss.nodes
                var newNode = _.find(newNodes, function (nod) {
                    return nod.index == nodeID;
                }.bind(this));
                newNode.param = par.substr(1);

                this.$.graphss.nodeMouseOver(newNode, par);

// 			propEdge.push({par1:par,par2:qo.getCurClasses()[index].getParameter(),propertu:property,ind1:otherInx,ind2:nodInd})

                this.$.graphss2.addNode2(par.substr(1), colorGlobal(_.find(newNodes, function (nod) {
                    return nod.index == nodInd
                }).vocab), nodInd);
                this.$.graphss2.addLink2(_.find(this.curQCN, function (a) {
                    return a.nodeId == this.currentNode.index
                }.bind(this)).param.substr(1), par.substr(1));


            },

            addClass: function (id) {
                this.classesList.push(id);
                this.classSelected = true;
            },

            removeClass: function (id) {
                var index = this.classesList.indexOf(id);
                this.classesList.splice(index, 1);
                if (this.classesList.length === 0)
                    this.classSelected = false;
            },

            classSelect: function (value) {
                if (value.target.checked)
                    this.addClass(parseInt(value.target.id));
                else {
                    this.removeClass(parseInt(value.target.id));
                }
            },

            selectAllClasses: function (value) {
                var div = this.$.classes.children[2].children;
                var len = div.length;
                var classBox;
                if (value.target.checked) {
                    for (i = 2; i < len; i++) {
                        classBox = div[i].children[0];
                        classBox.checked = true;
                        this.addClass(parseInt(classBox.id));
                    }
                }
                else {
                    for (i = 2; i < len; i++) {
                        classBox = div[i].children[0];
                        classBox.checked = false;
                        this.removeClass(parseInt(classBox.id));
                    }
                }
            },

            expandCommunity: function () {
                if (this.currentNode != null && this.classesList.length > 0) {
                    this.$.graphQuery.hidden = false;                    
                    this.removeGraph();
                    this.currentNode = null;
                    this.nodeClusters = this.ss.nodes;
                    this.edgeClusters = this.ss.links;
                    this.originalTitle = this.ss.title;
                    //this.$.graphss.ssChanged()
                    this.drawGraph();
                    this.communityExpanded = true
                }
            },

            expandClass: function () {
                var id = this.currentNode.id;
                this.addClass(id);
                this.removeGraph();
                this.drawGraph();
                this.currentNodeChanged();
            },


            removeGraph: function () {
                //d3.select(this.$.graphss.$.graph).selectAll("svg").remove();
                var div = this.$.graphss.$.graph;
                while (div.hasChildNodes() && div.lastChild.id !== "title") {
                    div.removeChild(div.lastChild);
                }
                //d3.select(this.$.classes).remove()


            },

            restoreClusters: function () {               
                this.ss.links = this.edgeClusters;
                this.ss.nodes = this.nodeClusters;
                this.classesList = [];
                this.currentNode = null;
                this.clearQuery();
                this.$.graphss2.clearQuery();
                this.$.graphss.ssChanged();
                this.communityExpanded = false;
                this.classSelected = false;
                this.ss.title = this.originalTitle;
            },


            drawGraph: function () {

                var vocab = this.ss.vocab;
                colorGlobal = d3.scale.category20();

                edges = [];
                classes = [];

                for (i = 0; i < this.classesList.length; i++) {
                    for (j = 0; j < this.ss.classeslinks.length; j++) {
                        if (isNaN(this.ss.classeslinks[j].source)) {
                            this.ss.classeslinks[j].source = this.ss.classeslinks[j].source.id;
                            this.ss.classeslinks[j].target = this.ss.classeslinks[j].target.id
                        }
                        if (this.classesList[i] === this.ss.classeslinks[j].source ||
                            this.classesList[i] === this.ss.classeslinks[j].target) {
                            if (edges.indexOf(this.ss.classeslinks[j]) === -1)
                                edges.push(this.ss.classeslinks[j])
                        }
                    }
                }

                this.ss.links = edges;

                for (i = 0; i < edges.length; i++) {
                    var index = classes.indexOf(this.ss.classes[edges[i].source]);
                    if (index < 0) {
                        classes.push(this.ss.classes[edges[i].source])
                    }
                    index = classes.indexOf(this.ss.classes[edges[i].target]);
                    if (index < 0) {
                        classes.push(this.ss.classes[edges[i].target])
                    }
                }

                var perc = Math.round((classes.length / this.ss.classes.length) * 100).toString();
                perc = perc.concat("%  ");
                this.ss.title = this.originalTitle;
                this.ss.title = perc.concat(this.ss.title);

                var max_ni = classes[0].ni;

                for (i = 1; i < classes.length; i++) {
                    if (classes[i].ni > max_ni)
                        max_ni = classes[i].ni;
                }

                svg = d3.select(this.$.graphss.$.graph).append("svg")
                    .attr("width", this.$.graphss.width)
                    .attr("height", this.$.graphss.height)
                    .append("g")

                var legend = svg.selectAll(".legend")
                    .data(this.ss.vocab)
                    .enter().append("g")
                    .attr("class", "legend")
                    .attr("y", "5px")
                    .attr("transform", function (d, i) {
                        return "translate(0," + ((i * 17) + 5) + " )";
                    });

                // draw legend colored rectangles
                legend.append("rect")
                    .attr("x", this.$.graphss.width - 15)
                    .attr("width", 15)
                    .attr("height", 15)
                    .style("fill", colorGlobal);

                // draw legend text
                legend.append("text")
                    .attr("x", this.$.graphss.width - 21)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .style("font-family", "Lato, sans-serif")
                    .style("font-size", "14px")
                    .style("font-weight", 900)
                    .text(function (d) {
                        return d;
                    });

                var rect = svg.append("rect")
                    .attr("width", this.$.graphss.width)
                    .attr("height", this.$.graphss.width)
                    .style("fill", "none")
                    .style("pointer-events", "all");

                var container = svg.append("g");
                var charge = (-4100) * 31 / this.ss.classes.length;


                var force = d3.layout.force()
                    .nodes(this.ss.classes)
                    .links(edges)
                    .gravity(0.9).linkDistance([50])
                    .charge(charge)
                    .friction(0.7)
                    .size([this.$.graphss.width, this.$.graphss.height])
                    .start();

                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 10])
                    .on("zoom", zoomed);

                svg.call(zoom);

                var drag = d3.behavior.drag()
                    .origin(function (d) {
                        return d;
                    })
                    .on("dragstart", dragstarted)
                    .on("drag", dragged)
                    .on("dragend", dragended);


                var links = container
                    .attr("class", "links")
                    .selectAll(".link")
                    .data(edges)
                    .enter().append("svg:line") //
                    .attr("class", "link")
                    .attr("id", function (d, i) {
                        return 'edge' + i;
                    })
                    .attr('marker-end', 'url(#arrowhead)')
                    .style("stroke-width", 1)
                    .attr("x1", function (d) {
                        return d.source.x;
                    })
                    .attr("y1", function (d) {
                        return d.source.y;
                    })
                    .attr("x2", function (d) {
                        return d.target.x;
                    })
                    .attr("y2", function (d) {
                        return d.target.y;
                    })//;

                autoedges = []
                for (i = 0; i < edges.length; i++) {
                    if (edges[i].source === edges[i].target) {
                        //    	    		console.log('autonode')
                        autoedges.push(edges[i])
                    }
                }

                var autoedges = container
                    .selectAll(".autoedges")
                    .data(autoedges)
                    .enter().append("svg:path") //
                    .attr("class", "link")
                    .attr("id", function (d, i) {
                        return 'autoedge' + i;
                    })
                    //.style("stroke-width", function(d) { return (d.np * 10 / max_np) + 1;; })
                    .style("stroke-width", "1.5px")
                    .attr("fill", "none")
                    // .attr('marker-end','url(#arrowhead)')
                    .style("stroke", 'black');
                //.style("pointer-events", "none");

                var nodes = container
                    .attr("class", "nodes")
                    .selectAll(".node")
                    .data(classes)
                    .enter().append("svg:circle")
                    .attr("class", "node")
                    .attr("stroke", "black")
                    .attr("stroke-width", "0.5px")
                    .attr("r", function (d) {
                        return (d.ni * 20 / max_ni) + 5;
                    }) //dimensione nodi
                    //     	      .on("dblclick", dblclick)
                    //     	      .on("click",nodeClick)
                    .style("fill", function (d) {
                        return colorGlobal(d.vocab);
                    })
                    .call(drag)

                var nodelabels = container
                    .attr("class", "nodelabel")
                    .selectAll(".nodelabel")
                    .data(classes)
                    .enter()
                    .append("text")
                    .attr({
                        "x": function (d) {
                            return d.x + (d.ni * 25 / max_ni) + 5 + stroke_width;
                        },
                        "y": function (d) {
                            return d.y;
                        },
                        "class": "nodelabel",
                        "id": function (d) {
                            return "nodelabel" + d.index
                        }
                    })
                    .style("font-family", "Lato, sans-serif")
                    .style("font-weight", 300)
                    .style("stroke", "black")
                    .attr("font-size", "13px")
                    .attr("fill", "black")
                    //     			.append("tspan")
                    //     			.attr('id',function(d){return "nodelabeltspan"+d.index})
                    .text(function (d) {
                        return d.name;
                    })
                //     	       .insertBefore(svg.select(function(d){return "#nodelabeltspan"+d.index}),document.createElement("tspan"))
                //     	       .text(function(d){return d.name;});

                nodes.append("title")
                    .text(function (d) {
                        return d.fullName;
                    });
                links.append("title")
                    .text(function (d) {
                        return d.name;
                    });

                svg.style("opacity", 1e-6)
                    .transition()
                    .duration(1000)
                    .style("opacity", 1);

                var edgepaths = svg.selectAll(".edgepath")
                    .data(edges)
                    .enter()
                    .append('path')
                    .attr({
                        'd': function (d) {
                            return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y
                        },
                        'class': 'edgepath',
                        'fill-opacity': 0,
                        'stroke-opacity': 0,
                        'fill': 'blue',
                        'stroke': 'red',
                        'id': function (d, i) {
                            return 'edgepath' + i
                        }
                    })
                    .style("pointer-events", "none");

                force.on("tick", function () {


                    nodes.attr({
                        "cx": function (d) {
                            return d.x = Math.max(10, Math.min(this.$.graphss.width - 10, d.x));
                        }.bind(this),
                        "cy": function (d) {
                            return d.y = Math.max(10, Math.min(this.$.graphss.height - 10, d.y));
                        }.bind(this)
                    });

                    links.attr({
                        "x1": function (d) {
                            return d.source.x;
                        },
                        "y1": function (d) {
                            return d.source.y;
                        },
                        "x2": function (d) {
                            return d.target.x;
                        },
                        "y2": function (d) {
                            return d.target.y;
                        }
                    });

                    nodelabels.attr("x", function (d) {
                        return d.x + (d.ni * 25 / max_ni) + 5 + stroke_width;
                    })
                        .attr("y", function (d) {
                            return d.y;
                        });


                    //     	        edgepaths.attr("x1", function(d) { return d.source.x; })
                    //     	        .attr("y1", function(d) { return d.source.y; })
                    //     	        .attr("x2", function(d) { return d.target.x; })
                    //     	        .attr("y2", function(d) { return d.target.y; });

                    edgepaths.attr('d', function (d) {
                        var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
                        //console.log(d)
                        return path
                    });


                    autoedges.attr("d", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            dr = Math.sqrt(dx * dx + dy * dy),
                            x1 = d.source.x,
                            y1 = d.source.y,
                            x2 = d.target.x,
                            y2 = d.target.y;

                        var xRotation = 0, // degrees
                            largeArc = 0, // 1 or 0
                            sweep = 1; // 1 or 0
                        xRotation = -45;

                        // Needs to be 1.
                        largeArc = 1;

                        // Change sweep to change orientation of loop.
                        //sweep = 0;

                        // Make drx and dry different to get an ellipse
                        // instead of a circle.
                        drx = 30;
                        dry = 20;

                        // For whatever reason the arc collapses to a point if the beginning
                        // and ending points of the arc are the same, so kludge it.
                        x2 = x2 + 1;
                        y2 = y2 + 1;
                        return "M" + x1 + "," + y1 + "A" + drx + "," + dry + " " + xRotation + "," + largeArc + "," + sweep + " " + x2 + "," + y2;

                    });

                }.bind(this));

                function zoomed() {
                    container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
                }

                function dragstarted(d) {
                    d3.event.sourceEvent.stopPropagation();

                    d3.select(this).classed("dragging", true);
                    //     	          console.log(force)
                    force.start();
                }

                function dragged(d) {

                    d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);

                }

                function dragended(d) {

                    d3.select(this).classed("dragging", false);
                }

                svg.selectAll('.node').on("mouseover", function (d) {
                    this.$.graphss.selected = d
                }.bind(this));

            },


            colorize: {
                toDom: function (value) {
                    return colorGlobal(value);
                }
            },
            goToSS: function (e, detail, sender) {
                console.log(detail.id);
                if (this.ss.id === detail.id) {

                } else {
                    this.reachable = null;
                    this.currentId = detail.id;
                    this.$.getSS.go();
                }
                this.selected = 1;
            },
            goToCS: function (e, detail, sender) {
                console.log("gotocs:" + detail.id)
                if (this.ss.id === detail.id) {

                } else {
                    this.reachable = null;
                    this.currentId = detail.id;
                    this.$.getCS.go();
                }
                this.selected = 1;
            },
            goToSStest: function (e, detail, sender) {
                console.log(detail.id)
                this.test = true;
                if (this.ss.id === detail.id) {

                } else {
                    this.reachable = null;
                    this.currentId = detail.id;
                    this.$.getSS.go();
                }
                this.selected = 1;
            },
            getSS: function (e) {
                this.communityExpanded = true;                
                this.isCluster = false;
                this.ss = e.detail.response;
                console.log(this.ss);
                this.curQCN = [];
                this.currentNode = null;
                this.propertylist = {};
                this.queryStarted = false;
                width = this.getBoundingClientRect().width * 0.99;
                height = this.getBoundingClientRect().height * 0.99;
// 			console.log(width,height)
                this.testSoundnessEndpoint();
            },
            getCS: function (e) {
                this.isCluster = true;
                this.communityExpanded = false;                
                this.$.graphss.ssChanged()
                this.ss = e.detail.response;
                console.log(this.ss);
                this.curQCN = [];
                this.currentNode = null;
                this.propertylist = {};
                this.queryStarted = false;
                width = this.getBoundingClientRect().width * 0.99;
                height = this.getBoundingClientRect().height * 0.99;
// 			console.log(width,height)
                this.testSoundnessEndpoint();
            },
            testSoundnessEndpoint: function () {
                var query = "SELECT ?s ?p ?o {?s ?p ?o} LIMIT 1";
                var queryUrl = encodeURI(this.ss.uri + "?query=" + query + "&format=json");
                if (this.ss.uri.toLowerCase().indexOf('poolparty') > -1) {
                    queryUrl = queryUrl + '&content-type=application%2Fjson';
                    $.ajax({
                        url: queryUrl,
                        timeout: 2000,
                        success: function (_data) {
                            console.log('succes')
                            var results = _data.results.bindings;
                            if (results.length > 0) {
                                this.reachable = true
                            }
                        }.bind(this),
                        error: function (jqXHR, error, errorThrown) {
                            this.reachable = false;
                        }.bind(this)
                    });
                } else {
                    $.ajax({
                        dataType: "jsonp",
                        url: queryUrl,
                        timeout: 2000,
                        success: function (_data) {
                            console.log('succes')
                            var results = _data.results.bindings;
                            if (results.length > 0) {
                                this.reachable = true
                            }
                        }.bind(this),
                        error: function (jqXHR, error, errorThrown) {
                            this.reachable = false;
                        }.bind(this)
                    });
                }

            },
            reachableChanged: function () {
                console.log(this.reachable)
                if (this.reachable === false) {
                    this.$.endNotReach.show();
                }
// 			alert(this.reachable)
            },
            overNode: function (e, detail, sender) {
// 	        console.log(e,detail,sender)
                this.currentNode = this.$.graphss.selected;
// 	        console.log(this.currentNode)
            },
            sMouseOver: function (e, detail, sender) {
// 	    	console.log(e,detail,sender)
                var nodeID = e.detail.nodeID
                this.currentNode = _.find(this.ss.classes, function (a) {
                    return a.index == nodeID
                }.bind(this))
                this.currentNode.param = e.detail.id
                this.currentNodeChanged()
            },
            currentNodeChanged: function () {
                /*  if(this.communityExpanded)  {
                      //this.classesList = []
                      var newLinks = [];
                      var newNodes = [];

                      for(i=0;i<this.ss.classeslinks;i++){
                          if(this.currentNode.id === this.ss.classeslinks[i].source ||this.currentNode.id === this.ss.classeslinks[i].target )
                              newNodes.push({"id":this.currentNode.id});
                              newLinks.push({"source": this.ss.classeslinks[i].source, "target": this.ss.classeslinks[i].target})
                      }
                  }else*/
                if (this.currentNode != null) {
                    if (!this.communityExpanded) {
                        this.classesList = [];
                        this.$.classes.children[1].children[1].checked = false;
                    } else this.$.explore.hidden = this.checkClass(this.currentNode.id);


                    var entranti = []
                    var uscenti = []
                    var edges = this.ss.links
                    var pos = 0;
                    for (i = 0; i < edges.length; i++) {
                        if (edges[i].source.index == this.currentNode.index) {
                            for (j = 0; j < edges[i].label.length; j++) {
                                tmp = edges[i].label[j]
                                tmp.target = edges[i].target.name
                                tmp.ClassfullName = edges[i].target.fullName
                                tmp.index = edges[i].target.index
                                tmp.card = (tmp.np / this.currentNode.ni).toFixed(2)
                                tmp.colProp = colorGlobal(tmp.vocab)
                                tmp.pos = pos
                                pos = pos + 1;
                                tmp.nodeId = -1;
                                if (_.some(this.curQCN, function (node) {
                                        return node.nodeId == this.currentNode.index
                                    }.bind(this))) {
                                    tmp.isInQuery = true

                                } else {
// 	    	  	    	  		if(_.some(this.curQCN,function(node){return node.nodeId==tmp.index}.bind(this))){
// 	    	    				tmp.isInQuery=true
// 	    	    				tmp.nodeID=_.find(this.curQCN,function(node){return node.nodeId==tmp.index}.bind(this)).nodeId
// 	    	  	    	  		}else{
                                    tmp.isInQuery = false
// 	    	  	    	  		}
                                }

                                uscenti.push(tmp)
                            }
                        }
                        else {
                            if (edges[i].target.index == this.currentNode.index) {
                                for (j = 0; j < edges[i].label.length; j++) {
                                    tmp = edges[i].label[j]
                                    tmp.source = edges[i].source.name
                                    tmp.ClassfullName = edges[i].source.fullName
                                    tmp.index = edges[i].source.index
                                    tmp.colProp = colorGlobal(tmp.vocab)
                                    tmp.card = (tmp.np / this.currentNode.ni).toFixed(2)
                                    tmp.pos = pos
                                    pos = pos + 1;
                                    if (_.some(this.curQCN, function (node) {
                                            return node.nodeId == this.currentNode.index
                                        }.bind(this))) {
                                        tmp.isInQuery = true
                                    } else {
// 			    	  	    	  	if(_.some(this.curQCN,function(node){return node.nodeId==tmp.index}.bind(this))){
// 			    	    				tmp.isInQuery=true
// 			    	  	    	  	}else{
                                        tmp.isInQuery = false
// 			    	  	    	  	}
                                    }

                                    entranti.push(tmp)

                                }
                            }
                        }
                    }
                    entranti.sort(function (a, b) {
                        return b.np - a.np;
                    });
                    uscenti.sort(function (a, b) {
                        return b.np - a.np;
                    });


                    this.currentNode.att = this.currentNode.att.map(function (a) {
                        a.color = colorGlobal(a.vocab);
                        if (_.some(this.curQCN, function (node) {
                                return (node.nodeId == this.currentNode.index && node.param.substr(1) == this.currentNode.param)
                            }.bind(this))) {
                            tmpCurNode = _.find(this.curQCN, function (node) {
                                return (node.nodeId == this.currentNode.index && node.param.substr(1) == this.currentNode.param)
                            }.bind(this))
// 		    			  console.log(tmpCurNode)
                            tmpAtt = null;

                            for (i = 0; i < tmpCurNode.attributes.length; i++) {
// 		    				  console.log(tmpCurNode.attributes[i])
                                if (tmpCurNode.attributes[i].fullName == a.fullName) {
                                    tmpAtt = tmpCurNode.attributes[i]
                                }
                            }
// 		    			  tmpAtt=_.find(tmpCurNode.attributes,function(b){return b.fullName==a.fullName}.bind(a))
// 		    			  console.log(tmpAtt)
                            if (tmpAtt != null) {
                                a.setted = true
                                a.isInQuery = false
                                a.optional = tmpAtt.opt
                            } else {
                                a.setted = false
                                a.isInQuery = true
                            }

                        } else {
                            a.setted = false
                            a.isInQuery = false
                        }
                        return a;
                    }.bind(this))
                    this.propertylist.entranti = entranti;
                    this.propertylist.uscenti = uscenti;
                }

            }
        });
    </script>



</body>

</html>